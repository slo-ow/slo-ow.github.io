---
title:  "서버 개발 면접 대비"
categories: Interview
tags:
  - Interview Web Jsp Spring Java DB Server
toc: true
toc_label: "On this Page"
toc_icon: "cog"
header:
  overlay_image: "/assets/instacode.png"
  overlay_filter: 0.5
  image_description: "header cover image"
---


앞으로 다가올 서버 개발자 면접을 위해 예상 질문 리스트를 만들어 보았다

질문 리스트는 나의 자소서 내용 중심으로 질문지가 구성 될 것이다


## [질문 리스트]
### 1. __웹 3계층__ 이 어떻게 동작하는지 설명하세요.

3계층 구조란 `프레젠테이션 로직(클라이언트, 사용자 인터페이스), 비즈니스 로직, 데이터베이스 로직`을 각각 다른 플랫폼 상에서 구현한 것이다. 3계층 구조에서 각 계층은 물리적으로도 독립적이며 각 계층의 변경이 다른 계층에 의존하지 않는다.

* __`프레젠테이션(클라이언트) 계층`__

프레젠테이션 계층은 응용 프로그램의 최상위에 위치하고 있는데 이는 서로 다른 층에 있는 데이터 등과 커뮤니케이션을 한다.
- 사용자 인터페이스를 지원한다. (인터넷 브라우저의 정적인 데이터를 제공한다.)    
- 이 계층은 GUI, 또는front-end도 불린다.
- 비즈니스로직이나 데이터관리코드를 포함해서는 안된다.
- 주로 웹서버를 뜻한다(물리적 : WEB서버)
ex) HTML, javascript, CSS, image



* __`애플리케이션 계층`__

이 계층은 비즈니스 로직 계층 또는 트랜잭션 계층이라고도 하는데, 비즈니스 로직은 워크스테이션으로부터의 클라이언트 요청에 대해 마치 서버처럼 행동한다. 차례로 어떤 데이터가 필요한지를 결정하고, 메인프레임 컴퓨터 상에 위치하고 있을 세 번째 계층의 프로그램에 대해서는 마치 클라이언트처럼 행동한다.

- 정보처리의 규칙을 가지고 있다.(동적인 데이터를 제공한다)
- middleware 또는 back-end로 불린다.
- 프레젠테이션코드나 데이터관리 코드를 포함해서는 안된다.
- 주로 어플리케이션 서버를 뜻한다(물리적 : WAS서버)

ex) Java EE, ASP.NET, PHP

* __`데이터 계층`__

데이터 계층은 데이터베이스와 그것에 액세스해서 읽거나 쓰는 것을 관리하는 프로그램을 포함한다. 애플리케이션의 조직은 이것보다 더욱 복잡해질 수 있지만, 3계층 관점은 대규모 프로그램에서 일부분에 관해 생각하기에 편리한 방법이다.

- 데이터베이스를 주로 뜻한다.
- DB 또는 File System를 접근 및 관리한다.
- back-end라고도 불린다.
- 주로 DB서버를 뜻한다(물리적 : DB서버)

ex) MySQL DB, Oracle DB

<hr/>

### 2. __웹 서버__ 와 __WAS__ 의 각각의 특징과 차이점을 설명하세요.

#### 웹 서버
* __`웹 서버의 개념`__
  + 웹 서버는 소프트웨어와 하드웨어로 구분된다.
  + __1) 하드웨어__
    - Web 서버가 설치되어있는 컴퓨터
  + __2) 소프트웨어__
    - 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠(.html .jpeg .css 등)를 제공하는 컴퓨터 프로그램

* __`웹 서버의 기능`__
  + __HTTP 프로토콜을 기반으로 하여 클라이언트(웹 브라우저 또는 웹 크롤러)의 요청을 서비스 하는 기능__ 을 담당한다.
  + __기능 1)__
    - 정적인 컨텐츠 제공
    - WAS를 거치지 않고 바로 자원을 제공한다.
  + __기능 2)__
    - 동적인 컨텐츠 제공을 위한 요청 전달
    - 클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(응답, Response)한다.
    - 클라이언트는 일반적으로 웹 브라우저를 의미한다.

* __`웹 서버의 예`__

Ex) Apache Server, Nginx, IIS(Windows 전용 Web 서버) 등

### WAS(Web Application Server)
* __`WAS(Web Application Server)의 개념`__
  + DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server
  + HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어(소프트웨어 엔진)이다.
  + "웹 컨테이너(Web Container)" 혹은 "서블릿 컨테이너(Servlet Container)"라고도 불린다.
    - Container란 JSP, Servlet을 실행시킬 수 있는 소프트웨어를 말한다. 즉, WAS는 JSP, Servlet 구동 환경을 제공한다.

* __`WAS의 역할`__
  + __WAS = Web Server  + Web Container__
  + 웹 서버 기능들을 구조적으로 분리하여 처리하고자하는 목적으로 제시되었다.
    - 분산 트랜잭션, 보안, 메시징, 쓰레드 처리 등의 기능을 처리하는 분산 환경에서 사용된다.
    - 주로 DB 서버와 같이 수행된다.
  + 현재는 WAS가 가지고 있는 웹 서버 도 __정적인 컨텐츠를 처리__ 하는 데 있어서 성능상 큰 차이가 없다.

* __`WAS의 주요 기능`__
  + 프로그램 실행 환경과 DB 접속 기능 제공
  + 여러 개의 트랜잭션(논리적인 작업 단위) 관리 기능
  + 업무를 처리하는 비즈니스 로직 수행

* __`WAS의 예`__

Ex) Tomcat, JBoss, Jeus, Web Sphere 등

### 웹 서버와 WAS를 구분하는 이유
* __웹 서버 가 필요한 이유?__
  + 클라이언트(웹 브라우저)에 이미지 파일(정적 컨텐츠)을 보내는 과정을 생각해보자.
    - 이미지 파일과 같은 정적인 파일들은 웹 문서(HTML 문서)가 클라이언트로 보내질 때 함께 가는 것이 아니다.
    - 클라이언트는 HTML 문서를 먼저 받고 그에 맞게 필요한 이미지 파일들을 다시 서버로 요청하면 그때서야 이미지 파일을 받아온다.
    - 웹 서버 를 통해 정적인 파일들을 Application Server까지 가지 않고 앞단에서 빠르게 보내줄 수 있다.
  + 따라서 __웹 서버 에서는 정적 컨텐츠만 처리하도록 기능을 분배하여 서버의 부담을 줄일 수 있다.__

* __WAS가 필요한 이유?__
  + 웹 페이지는 __정적 컨텐츠__ 와 __동적 컨텐츠__ 가 모두 존재한다.
    - 사용자의 요청에 맞게 적절한 동적 컨텐츠를 만들어서 제공해야 한다.
    - 이때, __웹 서버 만을 이용한다면 사용자가 원하는 요청에 대한 결과값을 모두 미리 만들어 놓고 서비스를 해야 한다.__
    - 하지만 이렇게 수행하기에는 __자원이 절대적으로 부족__ 하다.
  + 따라서 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와서 비즈니스 로직에 맞게 그때 그때 결과를 만들어서 제공함으로써 __자원을 효율적으로 사용__ 할 수 있다.

* __그렇다면 WAS가 웹 서버 의 기능도 모두 수행하면 되지 않을까?__
  + __1) 기능을 분리하여 서버 부하 방지__
    - WAS는 DB 조회나 다양한 로직을 처리하느라 바쁘기 때문에 단순한 __정적 컨텐츠는 웹 서버__ 에서 빠르게 클라이언트에 제공하는 것이 좋다.
    - __WAS는 기본적으로 동적 컨텐츠를 제공__ 하기 위해 존재하는 서버이다.
    - 만약 정적 컨텐츠 요청까지 WAS가 처리한다면 정적 데이터 처리로 인해 부하가 커지게 되고, 동적 컨텐츠의 처리가 지연됨에 따라 수행 속도가 느려진다.
    - 즉, 이로 인해 페이지 노출 시간이 늘어나게 될 것이다.

  + __2) 물리적으로 분리하여 보안 강화__
    - SSL에 대한 암복호화 처리에 __웹 서버__ 를 사용

  + __3) 여러 대의 WAS를 연결 가능__
    - Load Balancing을 위해서 __웹 서버__ 를 사용
    - fail over(장애 극복), fail back 처리에 유리
    - 특히 대용량 웹 어플리케이션의 경우(여러 개의 서버 사용) 웹 서버 와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다.
    - 예를 들어, 앞 단의 웹 서버 에서 오류가 발생한 WAS를 이용하지 못하도록 한 후 WAS를 재시작함으로써 사용자는 오류를 느끼지 못하고 이용할 수 있다.

  + __4) 여러 웹 어플리케이션 서비스 가능__
    - 예를 들어, 하나의 서버에서 PHP Application과 Java Application을 함께 사용하는 경우

  + __5) 기타__
    - 접근 허용 IP 관리, 2대 이상의 서버에서의 세션 관리 등도 웹 서버 에서 처리하면 효율적이다.

* 즉, 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성 을 위해 웹 서버 와 WAS를 분리한다.
* __웹 서버 를 WAS 앞에 두고 필요한 WAS들을 웹 서버 에 플러그인 형태로 설정하면 더욱 효율적인 분산 처리가 가능하다.__

<hr/>

### 3. 웹 서버 내부 구동 방식에 대해 설명할 수 있는가?
__웹 서버__ 는 클라이언트가 특정 페이지를 요청(Request)에 대해 처리한 후 결과를 클라이언트(웹 브라우저)에게 응답(Response)을 한다.

<hr/>

### 4. Servlet과 JSP의 차이점
* __Servlet__ : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것
* __JSP__ : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것

<hr/>

### 5. MVC 패턴이란?
* __Model__ : data 처리와 접근을 담당
* __View__ : Client에 보여지는 화면을 담당
* __Controller__ : Model과 View를 제어

하는 3가지 부분으로 나눔으로서, 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.

<hr/>

### 6. SpringFramework & Spring MVC & SpringBoot에 대해 설명하시오
* __SpringFramework__

__스프링 프레임워크__ 의 가장 중요한 특징은 `의존성 주입(Dependency Injection)` 이다. 모든 스프링 모듈들의 핵심에는 의존성 주입 이나 `IOC(Inversion of Control)` 가 있다.

이것이 중요한 이유는 DI나 IOC를 적절히 사용하면 우리는 느슨하게 결합된 애플리케이션들을 개발할 수 있기 때문이다. 또한 느슨하게 결합된 애플리케이션들은 단위테스트를 하기가 쉽다.

* __SpringMVC__

__Spring MVC__ 는 Dispatcher Servlet, ModelAndView, View Resolver 과 같은 단순개념을 이용해서 웹 애플리케이션 개발을 쉽게 할 수 있도록 해준다. 즉 Spring MVC는 말 그대로 MVC 구현을 할 수 있도록 지원해주는 스프링 프레임워크 이다.

* __SpringBoot__

__SpringBoot__ 는 Spring에서 제공하는 많은 라이브러리들을 기본 설정 값으로 __자동__ 으로 설정할 수 있도록 해준다. 따라서, Spring Boot는 Spring MVC를 편하게 사용할 수 있도록 해준다는 것 이다.

또한, Spring Boot 는 SpringMVC, Jackson, Validation 등 다양한 종속성들을 각각 패키지해 놓은 것을 함께 가져오기 때문에 개발자들은 이것들의 __호환버전에 대해 걱정할 필요가 없다.__


<hr/>


### 7. Request 전송 방식에는 어떤 것들이 있는지 아시나요?
* __Get 방식__ : URL의 쿼리문자열에 데이터를 같이 전달하는 방식으로 데이터 길이에 제한이 있고, 보안에 취약하다.
* __POST 방식__ : Body에 데이터를 넣어 보내기 때문에 보안에 조금 더 유리하고 데이터 길이에 제한이 없다. 하지만, Get에 비해 다소 느리다.
* __DELETE 방식__ : RESTFUL에서 삭제 기능을 할 때 주로 사용된다.
* __PUT/PUSH 방식__ : RESTFUL에서 수정 작업을 할 때 주로 사용된다.

<hr/>

### 8. RESTFUL이란?
해당 URL만 보더라도 바로 어떤 작업을 하는지를 알 수 있도록 하나의 데이터는 하나의 URL을 갖도록 작업하는 방식

[REST API 참고 자료](https://meetup.toast.com/posts/92)

<hr/>

### 9. Spring에서 DI란?
__DI__ 는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 `IOC 컨테이너`의 구체적인 구현 방식입니다.

DI는 기존처럼 개발코드 부분에서 객체를 생성(Ex. new wellcomeService())하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다.

이때, Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.


<hr/>

### 10. Spring의 AOP란? 그리고 AOP와 Interceptor 차이는 무엇인가?
#### AOP란?
__AOP__ 는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하고, 여전히 `로그`, `트랜잭션`, `자원해제`, `성능테스트 메서드` 처럼 __공통적 으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식입니다.__

이러한 __공통 코드__ 를 `"횡단 관심사"`라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다.

#### AOP와 Interceptor 차이
__AOP__: AOP는 `joinPoint`, `preceedingJoinpoint` 등의 파라미터를 활용하는 방식이다.

__Interceptor__: 인터셉터의 파라미터가 `HttpServletRequest`, `HttpServletResponse` 이다.

<hr/>

### 11. SQL Mapper와 ORM의 차이
__Persistence Framework__ 는 SQL Mapper와 ORM으로 나눌 수 있다.

* ORM은 데이터베이스 __객체를 자바 객체로 매핑__ 함으로써 객체 간의 관계를 바탕으로 SQL을 자동으로 생성해주지만 SQL Mapper는 SQL을 명시해줘야 한다.
* __ORM__ 은 관계형 데이터베이스의 __"관계"를 Object에 반영__ 하자는 것이 목적이라면, __SQL Mapper__ 는 단순히 __필드를 매핑__ 시키는 것이 목적이라는 점에서 __지향점의 차이__ 가 있다.

#### SQL Mapper
* SQL <—매핑—> Object 필드
* SQL Mapper는 SQL 문장으로 직접 데이터베이스 데이터를 다룬다.
  + 즉, SQL Mapper는 SQL을 명시해줘야 한다.
  + Ex) Mybatis, JdbcTempletes 등

#### ORM(Object-Relational Mapping), 객체-관계 매핑
* 데이터베이스 데이터 <—매핑—> Object 필드
  + 객체를 통해 간접적으로 데이터베이스 데이터를 다룬다.
* 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것을 말한다.
  + ORM을 이용하면 SQL Query가 아닌 직관적인 코드(메서드)로 데이터를 조작할 수 있다.
  + 객체 간의 관계를 바탕으로 SQL을 자동으로 생성한다.
* Persistant API라고도 할 수 있다.

Ex) JPA, Hibernate 등

##### __장점__
  + __객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.__
    - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.
    - 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
    - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
  + __재사용 및 유지보수의 편리성이 증가한다.__
    - ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용 할 수 있다.
    - 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
    - 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.
  + __DBMS에 대한 종속성이 줄어든다.__
    - 대부분 ORM 솔루션은 DB에 종속적이지 않다.
    - 종속적이지 않다는것은 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다.
    - 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.
    - 또한 자바에서 가공할경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.

##### __단점__
  + __완벽한 ORM 으로만 서비스를 구현하기가 어렵다.__
    - 사용하기는 편하지만 설계는 매우 신중하게 해야한다.
    - 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.
    - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.
    - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다.
    - DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성이 저하된다.)
  + __프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.__
    - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.
<hr/>

### 12. JDBC는 무엇인가?
* __Java Data Base Connection__ 의 약자로 JAVA 언어를 통해 데이터 베이스에 접근 할 수 있도록 Java에서 제공하는 API이다.
  + 모든 Java의 Data Access 기술의 근간
  + 즉, 모든 Persistence Framework는 내부적으로 JDBC API를 이용한다.
* JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.

<hr/>

### 13. Spring에서 MyBatis는 무엇인지 아시나요?
* 개발자가 지정한 SQL, 저장 프로시저 그리고 몇 가지 고급 매핑을 지원하는 __SQL Mapper__ 이다.
* __JDBC로 처리하는 상당 부분의 코드와 파라미터 설정 및 결과 매핑을 대신해준다.__
  + 기존에 JDBC를 사용할 때는 DB와 관련된 여러 __복잡한 설정(Connection)__ 들을 다루어야 했지만 SQL Mapper는 자바 객체를 실제 SQL문에 연결함으로써, 빠른 개발과 편리한 테스트 환경을 제공한다.
* 데이터베이스 record에 원시 타입과 Map 인터페이스 그리고 자바 POJO를 설정해서 매핑하기 위해 xml과 Annotation을 사용할 수 있다.
* MyBatis는 원래 Apache Foundation의 iBatis였으나, 생산성, 개발 프로세스, 커뮤니티 등의 이유로 Google Code로 이전되면서 이름이 바뀌었다.
  + iBatis와 바뀐 차이점은 아래와 같다.
    - JDK 1.5, Annotation
    - Dynatic SQL, XML Element
* __장점__
  + SQL에 대한 모든 컨트롤을 하고자 할때 매우 적합하다.
  + SQL쿼리들이 매우 잘 최적화되어 있을 때에 유용하다.
* __단점__
  + 애플리케이션과 데이터베이스 간의 설계에 대한 모든 조작을 하고자 할 때는 적합하지 않다.
    - 애플리케이션과 데이터베이스 간에 서로 잘 구조화되도록 많은 설정이 바뀌어야 하기 때문이다.

<hr/>

### 14. JPA/Hibernate는 무엇인가?
#### JPA
* 자바 ORM 기술에 대한 API 표준 명세로, Java에서 제공하는 API이다.
  + 자바 플랫폼 SE와 자바 플랫폼 EE를 사용하는 응용프로그램에서 __관계형 데이터베이스의 관리를 표현하는 자바 API이다.__
  + 즉, JPA는 __ORM을 사용하기 위한 표준 인터페이스를 모아둔 것__ 이다.
  + 기존에 EJB에서 제공되던 __엔터티 빈(Entity Bean)을 대체하는 기술__ 이다.
* __JPA 구성 요소__
  + `javax.persistance` 패키지로 정의된 API 그 자체
  + JPQL(Java Persistence Query Language)
  + 객체/관계 메타데이터
* 사용자가 원하는 JPA 구현체를 선택해서 사용할 수 있다.
  + JPA의 대표적인 구현체로는 `Hibernate`, EclipseLink, DataNucleus, OpenJPA, TopLink Essentials 등이 있다.
  + 이 구현체들을 `ORM Framework`라고 부른다.

#### Hibernate
* Hibernate는 __JPA의 구현체 중 하나__ 이다.
* Hibernate가 SQL을 직접 사용하지 않는다고 해서 JDBC API를 사용하지 않는다는 것은 아니다.
  + Hibernate가 지원하는 메서드 내부에서는 JDBC API가 동작하고 있으며, 단지 개발자가 직접 SQL을 직접 작성하지 않을 뿐이다.
* __HQL(Hibernate Query Language)__ 이라 불리는 매우 강력한 __쿼리 언어를 포함__ 하고 있다.
  + HQL은 SQL과 매우 비슷하며 추가적인 컨벤션을 정의할 수도 있다.
  + HQL은 완전히 객체 지향적이며 이로써 상속, 다형성, 관계등의 객체지향의 강점을 누릴 수 있다.
  + HQL쿼리는 자바 클래스와 프로퍼티의 이름을 제외하고는 대소문자를 구분한다.
  + HQL은 쿼리 결과로 객체를 반환하며 프로그래머에 의해 생성되고 직접적으로 접근할 수 있다.
  + HQL은 SQL에서는 지원하지 않는 페이지네이션이나 동적 프로파일링과 같은 향상된 기능을 제공한다.
  + HQL은 여러 테이블을 작업할 때 명시적인 join을 요구하지 않는다.
* __장점__
  + 객체지향적으로 데이터를 관리할 수 있기 때문에 비즈니스 로직에 집중 할 수 있으며, 객체지향 개발이 가능하다.
  + 테이블 생성, 변경, 관리가 쉽다. (JPA를 잘 이해하고 있는 경우)
  + 로직을 쿼리에 집중하기 보다는 객체자체에 집중 할 수 있다.
  + 빠른 개발이 가능하다.
* __단점__
  + 어렵다. (많은 내용이 감싸져 있기 때문에 알아야 할 것이 많다.)
  + 잘 이해하고 사용하지 않으면 데이터 손실이 있을 수 있다. (persistence context)
  + 성능상 문제가 있을 수 있다. (이 문제 또한 잘 이해해야 해결이 가능하다.)

<hr/>

### 15. Maven과 Gradle의 차이점
* __Maven은__ Build라는 동적인 요소를 XML로 정의하기에는 어려운 부분이 많다.
  + 설정 내용이 길어지고 __가독성__ 떨어짐
  + 의존관계가 __복잡한 프로젝트 설정하기에 부적절__
  + 상속구조를 이용한 멀티 모듈 구현
  + 특정 설정을 소수의 모듈에서 공유하기 위해서는 부모 프로젝트를 생성하여 상속하게 해야 함 (상속의 단점 생김)
* __Gradle은__ Groovy를 사용하기 때문에, 동적인 빌드는 Groovy 스크립트로 플러그인을 호출하거나 직접 코드를 짜면 된다.
  + Configuration Injection 방식을 사용해서 공통 모듈을 상속해서 사용하는 단점을 커버했다.
  + 설정 주입 시 프로젝트의 조건을 체크할 수 있어서 프로젝트별로 주입되는 설정을 다르게 할 수 있다.

<hr/>

### 16. Filter와 Interceptor 방식의 차이?
`영역 제어 측면`에서의 차이가 있는다. __Filter__ 는 웹 어플리케이션내에서 동작하므로, 스프링의 context 접근이 어렵다. __Interceptor__ 는 스프링의 context 내에 존재하므로 context내의 모든 객체를 활용할 수 있다.

<hr/>

### 17. 디자인 패턴 아는 것?
* 클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공한다.

__1. 싱글톤(SingleTone Pattern)__ : 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식입니다.

__2. 팩토리 패턴(Factory pattern)__ : 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는 생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식입니다.

__3. 옵저버 패턴(Observer Pattern)__ : 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로 사용됩니다.

<hr/>

### 18. 프로젝트 개발 순서??
1. 요구사항 분석 기획 및 스토리 보드 작성
2. WBS(Work Breakdown Structure) 작성: 작업 분해도로 프로젝트 범위와 최종산출물을 세부요소로 분할한 계층적 구조도
4. 논리 ERD 작성
5. 물리 ERD 작성
6. 개발
7. Testing
8. 유지보수

<hr/>

### 19. 스프링의 MVC에 대해서 설명하시오.
1. __클라이언트__ ---Request-> __서버__
2. 스프링에서 제공하는 __DispatcherServlet__ 이라는 클래스(일종의 frontController)가 요청을 가로챈다.
3. DispatcherServlet은 __HandlerMapping__ (URL 분석 등)에게 어떤 컨트롤러에 요청을 위임하면 좋은지 물어본다. (servlet-context.xml에서 @Controller로 등록한 것들을 스캔해서 찾음)
4. 요청에 매핑된 컨트롤러가 있으면 @RequestMapping을 통하여 요청을 처리할 메서드에 도달한다.
5. 컨트롤러는 해당 요청을 처리할 Service DI받아 비즈니스로직을 Service에 위임한다.
6. Service는 요청에 필요한 비즈니스로직을 처리, DB접근이 필요하면 DAO를 DI받아 DB처리는 DAO에 위임.
7. DAO는 myBatis(or Hibernate등) 설정을 이용해서 SQL 쿼리를 날려 DB의 정보를 받아 Service에 리턴. (보통 쿼리 결과는 DTO(VO)에 담는다)
8. __DAO__ ---Return-> __Service__ ---Return-> __Controller__
9. Controller는 Model객체에 결과물 어떤 view(jsp)파일을 보여줄 것인지등의 정보를 담아 DispatcherServlet에게 보낸다.
10. DispatcherServlet은 __ViewResolver에게 받은 뷰의 대한 정보__ 를 넘긴다.
11. ViewResolver는 해당 __JSP를 찾아서(응답할 View를 찾음) DispatcherServlet__ 에게 알려준다.
(servlet-context.xml에서 suffix, prefix를 통해 /WEB-INF/views/index.jsp 이렇게 만들어주는 것도 ViewResolver)
12. DispatcherServlet은 응답할 View에게 Render를 지시하고 View는 응답 로직을 처리한다.
13. 결과적으로 DispatcherServlet이 클라이언트에게 렌더링된 View를 응답한다.

##### 흐름 요약
* __Request__
> Client --> Server --> DispatcherServlet(HandlerMapping) --> Controller --> Service --> DAO
* __Response__
> DAO --> Service --> Controller --> DispatcherServlet(ViewResolver) --> View(Render) --> Client

<hr/>

### 20. "애자일" 방법론에 대해서 아는가?
간단히 말하면 __애자일__ 이란 `협력`과 `피드백`을 자주, 일찍, 더 잘하는 것을 의미한다

#### __애자일의 핵심1. "협력"__
* SW 프로젝트가 망하는 경우는 기술 외적인 것도 크다. 따라서 특히 SW 개발의 불확실성이 높을 때는 `"협력"` 을 잘 해야한다.

* 혼자 얻은 좋은 통찰을 협력을 통해 다른 사람도 같이 얻을 수 있다.
* 예상하지 못했던 기회를 잡을 수 있다.


* 문제가 되는 것을 찾기가 쉽다.
* 예상하지 못했던 문제를 협력이 막을 수 있다.


#### __애자일의 핵심2. "피드백"__
* `피드백`은 학습의 가장 큰 전제조건이다. 내가 어떻게 했는가를 확인하면서 학습해야 한다.
* 또한, SW 개발의 불확실성이 높을수록 `학습` 이 중요해진다. 왜냐하면 모르는 것이 많기 때문에 더 빨리 배워나가야하기 때문이다.
* 일을 잘하는 사람은 `feedback seeking` 이 뛰어나다. 즉, 이런 사람들은 더 자주 더 많은 사람들에게 피드백을 구한다.

* __내부적 피드백__
  + 내가 만든 것이 어떻게 됐는지 확인해보는 것
* __외부적 피드백__
  + 내가 만든 것을 고객이나 다른 부서가 사용해보고 그것을 통해 또 다른 것을 배우는 것

<hr/>

### 21. JSP 처리 과정(톰켓이 요청시)
1. 웹 브라우저가 jsp 파일을 요청
2. 웹 서버는 요청된 jsp 파일을 확인 후 웹 컨테이너로 전달
3. 웹 컨테이너는 JSP 파일을 서블릿 으로 변환 즉, .java 파일로 변환
4. 그후 컴파일하면 .class 파일이 나온다.
5. 다시 웹 서버로 전달하고 웹서버는 웹 브라우저에 HTML 형태로 전송한다.

<hr/>

### 22. IoC(Inversion of Control) 정의
인스턴스를 `제어하는 주도권이 역전`된다는 의미로 컴포넌트를 구성하는 __인스턴스 생성과 의존관계 연결__ 을 개발자 소스 코드가 아닌 __DI컨테이너가 대신__ 해 주기 때문에 제어가 역전 되었다고 한다.

<hr/>

### 23. IoC 컨테이너 정의
스프링 프레임워크가 제공하는 IoC컨테이너를 통해 인스턴스의 생명주기 관리 및 의존관계 주입을 처리한다.

<hr/>

### 24. IoC 컨테이너의 실체
일반적인 스프링 컨테이너이고 BeanFactory를 상속받은 하위 인터페이스인 ApplicationContext를 말한다.

<hr/>

### 25. 스프링 빈 정의
스프링 컨테이너가 관리하는 객체

<hr/>

### 26. WAC의 2가지(contextLoadListener, DispatcherServlet) 생성 과정을 설명
* WAC(Web Application Context): 웹 어플리케이션 컨텍스트
1. 웹 어플리케이션이 요청되면 __WAS__ 에 의해 __web.xml__ 이 로드 된다.
2. __web.xml__ 에 등록한 __`contextLoadListener`__ 가 생성되고 생성된 __contextLoadListener__ 는 __root-context.xml__ 을 로드한다.
3. __root-context.xml__ 에 등록된 __spring Container__ 가 구동 되고, 이때 개발자가 작성한 비즈니스 로직 DAO, VO 객체를 생성한다.
4. 클라이언트로부터 웹 어플리케이션이 요청이 오면 __`DispatcherServlet`__ 이 생성되고 __servlet-context.xml__ 을 로드한다.
5. __servlet-context.xml__ 는 __FrontController__ 의 역할을 수행한다.
6. __FrontController__ 는 클라이언트로부터 요청 온 메시지를 분석하여 알맞은 __pageController__ 에게 전달하고 응답받아 요청에 따른 응답을 어떻게 할지 결정만 한다.

<hr/>

### 27. 자바 웹 어플리케이션 설계 방식 3가지 차이점
* __Model 1__
  + JSP만 사용하여 개발하거나 java bean을 포함하여 개발하는 방식이다.
  + 뷰와 비즈니스 로직이 혼재 되어 복잡도가 높고 유지보수가 어렵다
* __Model 2__
  + MVC로 분리하여 개발 하는 방식이다 뷰와 비즈니스 로직을 분리하여 유지보수하기 좋다.
* __프론트 컨트롤러__
  + __클라이언트 요청을 프론트 컨트롤러에 집중__ 시키고 프론트 컨트롤러가 들어온 url을 Handler Mapping을 통하여 판단하여 적절한 컨트롤러에 넘겨주는 MVC방식 이다.
  + 또한, 프론트 컨트롤러는 컨트롤러가 return하는 뷰 이름을 ViewResolver를 통해 뷰 이름에 해당하는 view(jsp)를 호출한다.

<hr/>

### 28. 다형성(Polymorphism)이란?
서로 다른 클래스로부터 만들어진 객체지만 같은 부모의 Class 타입으로 이들을 관리할 수 있는(=대입될 수 있는) 성질
* [다형성 예시 참고](https://asfirstalways.tistory.com/168)
#### Wiki 정의
그 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들(상수, 변수, 식, 오브젝트, 함수, 메소드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질을 가리킨다.

<hr/>

### 29. 컬렉션프레임워크(CollectionFramework)에 대해 아는만큼 말해 보시오.
자바에서 `컬렉션 프레임워크(collection framework)`란 __다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합__ 을 의미합니다

즉, 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것입니다.

이러한 컬렉션 프레임워크는 자바의 인터페이스(interface)를 사용하여 구현됩니다.

#### Collection 인터페이스
1. __List 인터페이스__ : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.
   * ex) ArrayList : 배열로 구현됬으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다 하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를 옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.
   * ex) LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만 연결하면 되기 때문에 삽입, 삭제에 유리하다.
   * ex) Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리 Synchronized(동기화)가 걸려 있어 여러 쓰레드에서 동시에 접근할 수 없다.

2. __Set 인터페이스__ : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우 Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.
   * ex) HashSet
   * ex) TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어 졌다. 순서에 맞게 정렬되어 저장되기 위해서 Comparable을 구현해야한다.

3. __Map 인터페이스__ : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.
   * ex) HashMap
   * ex) TreeMap
   * ex) Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.
   * ex) Hashtable : HashMap과 구조는 같으며, 단지 Synchronized(동기화) 되어져 있다는 점이 다른점이다.

[참고 자료](http://tcpschool.com/java/java_collectionFramework_concept)

<hr/>

### 30. 캐시(Cache)와 세션(Session)의 공통점과 차이점은?
#### 공통점
  + 둘 다 사용자의 데이터를 저장한다.

#### 차이점
  + __캐시:__ 캐시는 Client 컴퓨터에 저장했다 서버 요청시 네트워크를 타고 서버로 전달되기 때문에 보안에 취약하다.
  + __세션:__ 세션은 서버에 저장되고 브라우저 단위로 관리된다. 캐시에 비해 보안성이 좋다.

<hr/>

### 31.  프로세스(Process) 와 쓰레드(Thread)의 차이점에 대해 아는가?
#### 프로세스
프로세스는 OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다.
이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에 서로 메모리 공간을 공유하지 못한다.
따라서, 공유하기 위해서는 IPC(InterProcess Communication)과 같은 방식이 필요하다.

#### 쓰레드
쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의 자원(메모리)는 프로세스 내에서 공유하게 된다.

<hr/>

### 32. GC 매커니즘
__자바__ 에서 더 이상 사용되지 않는 객체들은 `가비지 컬렉션`을 담당하는 프로세스가 자동으로 메모리에서 제거하도록 하는 것이 가비지 컬렉션의 기본 개념 이다.

자바는 `가비지 컬렉션`에 아주 단순한 규칙을 적용한다.

Heap 영역의 오브젝트 중 stack 에서 `도달 불가능한 (Unreachable) 오브젝트`들은 가비지 컬렉션의 대상이 된다.

HotSpot VM에서는 크게 2개로 물리적 공간을 나누었다. 둘로 나눈 공간이 `Young 영역`과 `Old 영역`이다.

#### Young 영역(Yong Generation 영역)
새롭게 생성한 객체의 대부분이 여기에 위치한다. 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말한다.
* Young 영역은 3개의 영역으로 나뉜다.
  + Eden 영역
  + Survivor 영역(2개)

#### Old 영역(Old Generation 영역)
접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. 이 영역에서 객체가 사라질 때 Major GC(혹은 Full GC)가 발생한다고 말한다.

#### 영역의 처리 절차 (요약)
__Eden 영역__ 에 최초로 객체가 만들어지고, Survivor 영역을 통해서 __Old 영역__ 으로 오래 살아남은 객체가 이동한다

> _GC에 대한 자세한 내용은 [가비지 컬렉션(Garbage Collection)](https://doorisopen.github.io/java/2020/02/05/java-gc.html) 이곳을 참고하세요_

<hr/>

### 33. Spring 의존성 주입 방법 3가지
#### xml 기반 DI
* xml을 이용한 DI에는 생성자 기반, 설정자(setter)기반 2가지 방법이 있다.
  + __사전조건:__ dao에 대한 빈 컴포넌트가 주입 되어야 한다.
* `생성자 기반`으로 한 의존성 주입은 생성자의 인수를 사용해 의존성을 주입하고 xml에 <constructor-arg> 태그를 사용하여 주입할 컴포넌트를 설정한다.
* `설정자(setter) 기반`으로 한 의존성 주입은 메서드의 인수를 통해 의존성을 주입하고 xml에 <property> 요소를 name 속성에 주입할 컴포넌트의 이름을 설정한다.

#### Annotation 기반 DI
 xml 파일에 `<context:annotation-config />` 설정을 통해서 xml에 등록된 빈들을 애노테이션 기능을 적용하기 위해 선언해주고 @Autowired를 사용하여 빈들 간의 의존 관계를 형성 시켜준다.
`<context:component-scan base-package=“패키지명”/>`를 xml 파일에 선언하여 특정 패키지 안에 클래스를 검색해서 빈을 자동으로 찾아서 DI컨테이너에 등록한다. 그리고 @Autowired를 사용하여 빈들 간의 의존관계를 형성 시켜준다.

#### Java 기반 DI
__xml 문법 대신 자바 코드로 빈을 설정한다.__ 자바 클래스 파일에 `@Configuration`을 입력하여 빈 설정을 위한 클래스를 선언해주고 사용할 빈 객체의 메소드에 `@Bean`을 사용하여 등록한다.
또한 name 속성을 사용하여 새로운 빈 이름을 적용할 수 있고 XML 에서는 `<property> 태그`나 `<constructor-arg> 태그` 를 이용해서 설정하였으나 자바 설정에서는 등록한 빈을 생성자의 매개변수로 넣어서 직접 의존 객체를 주입해야 한다.

<hr/>

### 33. 트랜잭션(Transaction)에 대해서 설명하시오
트랜잭션은 전체 로직이 __모두 다 반영__ 되거나 __모두 반영되지 않는__ 논리적인 작업의 묶음을 의미한다 (All or Nothing 방식을 취함)

#### 트랜잭션의 기본 원칙 (ACID)
##### 원자성(Atomicity)
한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않는다

##### 일관성(Consistency)
어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가진다

##### 고립성(Isolation)
한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션에서 접근할 수 없다

##### 지속성(Durability)
일단 한 트랜잭션이 완료되면 데이터베이스에 반영한 수행 결과는 영구적이어야 한다

<hr/>

### 34. Thread와 ThreadLocal의 차이
* `Thread`란 하나의 프로세스 내부에서 독립적으로 실행되는 하나의 작업 단위를 말하며, 세부적으로는 운영체제에 의해 관리되는 하나의 작업 혹은 태스크를 의미한다.

* `ThreadLocal`은 Thread에 안전하지 않은 객체가 있지만 해당 객체에 대한 액세스를 __동기화__ 하지 않으려는 경우 사용할 수 있다.

* `ThreadLocal`을 이용하면 Thread 영역에 변수를 설정할 수 있기 때문에, 특정 Thread가 실행하는 모든 코드에서 그 Thread에 설정된 변수 값을 사용할 수 있게 된다.
  + 즉, 같은 Thread내에서 값을 읽고 쓰기 위해서 사용하기 위함이다.

그러나, `ThreadLocal` 사용은 권장하지 않는다. 일반적인 대용량 시스템이 싱글 Thread 일리는 없고, 대부분 상용 시스템은 멀티 Thread 기반의 시스템을 구성한다.
그런데 이때, ThreadLocal 은 서로 다른 값을 갖기 때문에 용이성이 떨어진다. 만약, end-to-end 거래로 Thread 재활용성 없다면 용이하지만 추천하지 않는다.(정보의 유실 가능)

만약 쓰레드 풀 환경에서 ThreadLocal을 사용하는 경우 ThreadLocal 변수에 보관된 데이터의 사용이 끝나면 반드시 해당 데이터를 삭제해 주어야 한다. 그렇지 않을 경우 재사용되는 쓰레드가 올바르지 않은 데이터를 참조할 수 있다.

### ThreadLocal 사용 예시
* 사용자 인증정보 전파 – Spring Security에서는 ThreadLocal을 이용해서 사용자 인증 정보를 전파한다.
* 트랜잭션 컨텍스트 전파 – 트랜잭션 매니저는 트랜잭션 컨텍스트를 전파하는 데 ThreadLocal을 사용한다.
* 쓰레드에 안전해야 하는 데이터 보관

[ThreadLocal 참고 자료](https://mm4mm.tistory.com/42), [ThreadLocal 사용법과 활용 참고 자료](https://javacan.tistory.com/entry/ThreadLocalUsage)

<hr/>

### 35. vue, react 차이점


#### Vue
* Template 과 Render Function 을 모두 사용할 수 있는 옵션
* 간편한 Syntax 와 프로젝트 설정
* 빠른 렌더링과 더 작은 용량
* Vue 가 버전 2.x 부터 Template 과 render() 를 모두 지원

#### React
* React App 은 Template 구조를 사용하지 않고, 개발자가 `JSX` 를 사용하여 __자바스크립트에서 DOM 을 생성__ 합니다.
* 큰 규모에서 더 빛을 발하고, 테스팅이 수월
* Web 과 Native 앱 개발에 모두 사용 가능
* 더 큰 개발자 생태계에서 오는 많은 레퍼런스와 도구들


#### 공통
* Virtual DOM 으로 빠른 렌더링
* 경량 라이브러리
* Reactive Component
* Server Side Rendering
* 라우터, 번들러, state management 와 결합이 쉬움
* 훌륭한 개발자 커뮤니티와 지원

[React 인가 Vue 인가?](https://joshua1988.github.io/web_dev/vue-or-react/)

<hr/>

### 36. Cookie vs Localstorage 차이점
`Cookies`는 앱 또는 웹사이트를 방문하는 유저들에 대한 정보를 저장하는 주된 방법이었습니다. cookies들은 쇼핑 카트 항목들 또는 유저에 의해 변경된 옵션같은 상태를 기록하는데 사용되었습니다. 그리고 유저가 검색한 것을 기억하거나 페이지 간 이동했을때 로그인 상태를 유지하는데에 사용되었습니다. 그러다가 HTML5가 등장했고 `LocalStorage`를 다른 데이터 저장 옵션으로 도입했습니다. 이 __새로운 Javascript 객체 (SessionStorage와 LocalStorage)는 5MB의 저장 공간이 있어서 cookies보다 더 많은 저장 용량을 자랑합니다.__

#### Cookies
* __Cookies__ 는 웹사이트에 의해 유저의 컴퓨터에 놓여지는 작은 텍스트 파일들입니다.
* __Cookies__ 는 최대 4KB의 용량을 가진 매우 작은 양의 데이터입니다.
* __Cookies__ 는 사이트에서 방문한 페이지를 저장하거나 유저의 로그인 정보를 저장하는 등 다양한 방법으로 사용됩니다. 그리고 __문자열만 저장할 수 있다는 제한__ 이 있습니다.
* 많은 보안 웹사이트들은 로그인을 한 후 Cookies를 사용해 유저의 신원을 확인하여 __모든 페이지에서 재인증을 거치지않아도 되게__ 됩니다.
* Cookies의 또 다른 용도는 사이트에서 제한된 __인터넷 사용 기록을 기반으로 사용자 경험을 개선__ 하는 것입니다.

##### Cookies의 두 가지 유형
* `Session cookies`는 __만료일을 포함하지 않습니다.__ 대신에 브라우저나 탭이 열려있는 동안에만 저장됩니다. 브라우저가 닫히면 cookies는 영구적으로 삭제됩니다. 이 유형의 cookies는 은행 웹사이트 내에서 작업을 하고 있다가 탭을 닫으면 모든 정보를 잊어버리기 때문에 은행 유저들의 자격 증명을 저장하는데 사용될 수 있습니다.
* `Persistent cookies`는 __만료일을 가집니다.__ 이 cookies는 만료일까지 유저의 디스크에 저장되고 만료일이 지나면 삭제됩니다. 유저들이 방문할때마다 유저 경험을 커스텀하기 위해 특정 웹사이트에서 행동을 기록하는 등 여러 활동들에 사용될 수 있습니다.

#### LocalStorage
HTML5가 나온 이후, cookies의 많은 사용 방법들은 `LocalStorage`의 사용으로 대체되었습니다. LocalStorage는 cookies보다 더 많은 장점이 있기 때문입니다.

* __가장 중요한 차이점 중 하나는 cookies와는 달리모든 HTTP 요청에서 데이터를 주고받을 필요가 없다.__
  + HTTP 요청에서 데이터를 주고받지 않고 LocalStorage를 이용하면 클라이언트와 __서버간의 전체 트래픽과 낭비되는 대역폭의 양을 줄일 수 있습니다.__
  + 데이터가 유저의 로컬 디스크에 저장되어 있으면 인터넷이 끊어져도 데이터가 삭제되거나 지워지지 않기 때문입니다.
  + LocalStorage는 최대 5MB의 정보를 저장할 수 있습니다. 이것은 cookies가 보유할 수 있는 4KB보다 훨씬 더 많습니다.

LocalStorage의 만료 조건은 persistent cookies처럼 동작합니다. Javascript 코드를 통해 삭제하지 않으면 데이터는 자동으로 삭제되지 않습니다. 이 방식은더 오랜 시간동안 저장해야하는 큰 데이터에 유용합니다. 또한 LocalStorage를 사용하면 문자열 뿐만아니라 javascript의 primitives와 object도 저장할 수 있습니다.

* LocalStorage의 좋은 사용 예시는 __인터넷 연결이 잘 유지되지 않는 지역에서 사용되는 애플리케이션__ 일 것이다.
* LocalStorage를 잘 사용하려면 이 상황에 __저장된 데이터의 위협 수준이 매우 낮아야한다__
* LocalStorage를 사용할때 쉽게 __해킹되지 않도록 저장된 데이터를 암호화__ 하는 것이 좋습니다.

#### 결론
cookies는 더 작고 모든 HTTP 요청과함께 서버 정보를 다시 전달해주지만 LocalStorage는 더 크고 클라이언트 측에 정보를 보유할 수 있습니다.

<hr/>

### 37. JAVA에서 abstract 과 interface 의 차이는 무엇인가
#### abstract
`추상 메소드(abstract method)`란 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드를 의미합니다. 자바에서 추상 메소드를 선언하여 사용하는 목적은 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함입니다.

예를 들면 모듈처럼 중복되는 부분이나 공통적인 부분은 미리 다 만들어진 것을 사용하고, 이를 받아 사용하는 쪽에서는 자신에게 필요한 부분만을 재정의하여 사용함으로써 생산성이 향상되고 배포 등이 쉬워지기 때문입니다.

#### interface
`인터페이스(interface)란` 자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있다는 장점을 가지게 될 것입니다.
하지만 클래스를 이용하여 다중 상속을 할 경우 메소드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은 지원하지 않습니다.

하지만 다중 상속의 이점을 버릴 수는 없기에 자바에서는 __인터페이스라는 것을 통해 다중 상속을 지원하고 있습니다.__
`인터페이스(interface)란` 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미합니다.

자바에서 추상 클래스는 추상 메소드뿐만 아니라 생성자, 필드, 일반 메소드도 포함할 수 있습니다. 하지만 인터페이스(interface)는 오로지 추상 메소드와 상수만을 포함할 수 있습니다.

#### 결론
인터페이스는 구현해내는 클래스에서 인터페이스의 모든 method 들을 반드시 override 해야만한다. 반면 abstract는 abstract로 선언된 method 만 구현하면된다.

<hr/>

### 38. webpack 이란
서버에서 처리하는 로직을 JavaScript로 구현하는 부분이 많아지면서 웹 서비스 개발에서 JavaScript로 작성하는 코드의 양도 늘어났습니다. 코드의 양이 많아지면 코드의 유지와 보수가 쉽도록 코드를 모듈로 나누어 관리하는 모듈 시스템이 필요해집니다. 그러나 JavaScript는 언어 자체가 지원하는 모듈 시스템이 없습니다. 이런 한계를 극복하려 여러 가지 도구를 활용하는데 그 도구 가운데 하나가 `webpack`입니다.

`webpack`은 __모듈 시스템을 구성하는 기능__ 외에도 __로더 사용__, __빠른 컴파일 속도__ 등 장점이 많다

webpack {엔트리 파일 경로} {번들 파일 경로} 형식으로 명령어를 실행해 __모듈을 컴파일__ 한다.

``` js
webpack ./entry.js bundle.js  
```

`엔트리 파일`은 __서로 의존 관계에 있는 다양한 모듈을 사용하는 시작점이 되는 파일이다.__ `번들 파일`은 브라우저에서 실행할 수 있게 __모듈을 컴파일한 파일__ 이다.

__webpack에서 컴파일은 엔트리 파일을 시작으로 의존 관계에 있는 모듈을 엮어서 하나의 번들 파일을 만드는 작업이다.__

JavaScript를 사용하는 HTML 코드에서는 컴파일 결과로 만들어진 __번들 파일만 포함__ 하면 된다.

참고) 컴파일 명령어에 --watch 옵션을 사용하면 모듈 파일이 변경될 때마다 변경된 모듈을 자동으로 다시 컴파일한다.

``` js
webpack --watch ./entry.js bundle.js  
```

[webpack 참고 자료](https://d2.naver.com/helloworld/0239818)

<hr/>

## 39. 해쉬테이블 탐색에 걸리는 시간?
Hash Table이 가장 큰 장점은 검색속도가 매우 빠른다는 것 이다.

그 이유는 Hash 함수로 만든 Hash code는 정수이다. 그리고 고정된 크기의 배열을 만들어 놓고 hash code를 배열의 개수로 나머지 연산을 해서 배열에 나눠 담는다.

hash code 자체가 배열 방의 인덱스로 사용되기 때문에 검색 자체를 할 필요가 없고 hash code로 데이터의 위치에 직접 접근 할 수 있어서 빠른것이다.

그러나, Hash Algorithm(규칙)을 어떻게 작성하는가에 따라서 공간 효율이 달라진다(collison 발생)

따라서, Hash Algorithm 에 따라 `O(1)` 와 collison일 경우 최대 검색 시간이 `O(n)`만큼 걸린다.

### 결론
* Hash Table의 사전조건은 __고정된 크기의 배열을 선언__ 하는 것 이다.
* key 값을 hash 함수를 이용하여 hash code로 만든다
* hash code는 고정된 배열의 개수로 나머지 연산을 해서 배열에 나눠 담는다.
* Hash Table의 검색속도는 `Hash Algorithm` 에 따라 `O(1)` 와 __collison__ 일 경우 최대 검색 시간이 `O(n)`만큼 걸린다.

<hr/>

### 40. Message Queue 란?
`메시지 큐(Message Queue 이하 MQ)`란 프로세스(프로그램) 간에 데이터를 교환할 때 사용하는 통신 방법 중에 하나로 더 큰 개념으로는 MOM(Message Oriented Middleware : 메시지 지향 미들웨어 이하 MOM)를 의미합니다.

`메시지 큐(Message Queue 이하 MQ)`란 메시지 기반의 미들웨어로 메시지를 이용하여 여러 어플리케이션, 시스템, 서비스들을 연결해주는 솔루션이다.

`MOM`이란 비동기 메시지를 사용하는 프로그램 간의 데이터 송수신을 의미하는데 MOM을 구현한 시스템을 MQ라고 합니다. MQ는 작업을 늦출 수 있는 유연성을 제공합니다.

MOM(Message Oriented Middleware) 를 구현한 솔루션으로 비동기 메시지를 사용하는 서비스들 사이에서 데이터를 교환해주는 역할을 한다.

Producer(sender) 가 메시지를 큐에 전송하면 Consumer(receiver) 가 처리하는 방식으로, producer 와 consumer 에 message 프로세스가 추가되는 것이 특징이다.


[MQ 참고자료](https://steady-snail.tistory.com/165)

<hr/>

### 41. DOM
`DOM`은 __HTML 문서에 대한 인터페이스입니다.__ 기본적으로 여러 프로그램들이 페이지의 콘텐츠 및 구조, 그리고 스타일을 읽고 조작할 수 있도록 API를 제공합니다.

1. Dom은 HTML 요소들의 구조화된 표현 이다.
2. Dom은 뷰 포트에 무엇을 렌더링 할지 결정하기 위해 사용된다.
3. Dom은 페이지의 콘텐츠 및 구조, 그리고 스타일이 자바스크립트 프로그램에 의해 수정되기 위해 사용됩니다.

DOM은 원본 HTML 문서 형태와 비슷하지만 몇 가지 차이점이 있습니다.

* 항상 유효한 HTML 형식입니다.
* 자바스크립트에 수정될 수 있는 동적 모델이어야 합니다.
* 가상 요소를 포함하지 않습니다. (Ex. ::after)
* 보이지 않는 요소를 포함합니다. (Ex. display: none)

[DOM 참고 자료](https://wit.nts-corp.com/2019/02/14/5522)

<hr/>

### 42. Spring batch
`Spring Batch`는 로깅/추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작, 건너 뛰기 및 자원 관리를 포함하여 __대량의 레코드를 처리하는 데 필수적인 재사용 가능한 기능__ 을 제공합니다.

또한, 최적화 및 파티셔닝 기술을 통해 __대량의 고성능 배치 작업을 수행 할 수있는 고급 기술 서비스 및 기능을 제공__ 합니다.

단순하고 복잡한 대량 배치 작업은 확장 가능한 방식으로 프레임 워크를 활용하여 많은 양의 정보를 처리 할 수 ​​있습니다.

배치의 일반적인 시나리오는 다음과 같은 3단계로 이루어집니다.

* __읽기(read):__ 데이터 저장소(일반적으로 데이터베이스)에서 특정 데이터 레코드를 읽습니다.
* __처리(processing):__ 원하는 방식으로 데이터 가공/처리 합니다.
* __쓰기(write):__ 수정된 데이터를 다시 저장소(데이터베이스)에 저장합니다.


[batch 참고 자료1](https://en.wikipedia.org/wiki/Spring_Batch),
[batch 참고 자료2](https://cheese10yun.github.io/spring-batch-basic/)

<hr/>

### 43. 직렬화란 무엇인가
자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동했습니다. 하지만 객체는 바이트형이 아니라서 스트림을 통해 파일에 저장하거나 네트워크로 전송할 수 없습니다. 따라서 객체를 스트림을 통해 입출력하려면 바이트 배열로 변환하는 것이 필요한데, 이를 '직렬화' 라고 합니다. 반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정을 역직렬화라고 합니다.

<hr/>

### 44. 리플렉션이란 무엇인가요
리플렉션은 컴파일러를 무시하고 런타임 상황에서 메모리에 올라간 클래스나 메서드등의 정의를 동적으로 찾아서 조작할 수 있는 일련의 행위를 말합니다. 즉 동적인 언어의 특징이라 말 할 수 있습니다. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용하기도 합니다.

<hr/>

<br/>
<br/>

### 알고리즘 인터뷰(Hand Write Coding)
* [알고리즘 인터뷰 가이드 1: 준비편](http://theyearlyprophet.com/interviews-101-preparation.html)
* [코딩 면접](http://mrkimkim.com/diary/test-interview-review/%ec%bd%94%eb%94%a9-%eb%a9%b4%ec%a0%91-%ed%9b%84%ea%b8%b0-%ed%98%bc%ec%9e%90%ec%84%9c-%ec%bd%94%eb%94%a9-%eb%a9%b4%ec%a0%91-%ec%a4%80%eb%b9%84%ed%95%98%ea%b8%b0/)
<br/>
<br/>

<hr />
### References
> * From by [doorisopen](https://doorisopen.github.io/)
> * [basic-concepts-of-development-spring](https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-spring.html)
> * [webserver-vs-was](https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html)
> * [https://bkim.tistory.com/13](https://bkim.tistory.com/13)
> * [tech-interview](https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md#orm%EC%9D%B4%EB%9E%80)
> * [쿠키 vs 로컬스토리지: 차이점은 무엇일까?](https://medium.com/@erwinousy/%EC%BF%A0%ED%82%A4-vs-%EB%A1%9C%EC%BB%AC%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-28b8db2ca7b2)
> * [개발자-면접-질문자바-스프링](https://ktko.tistory.com/entry/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81)
